# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i3fPESZFeWRoW1GVt-juCbum1jGqNq4D
"""

import pandas as pd
import numpy as np

df = pd.read_csv("goszakup_tenders_full_async.csv")

df

df.info()

# ЯЧЕЙКА 1: Базовые импорты

import pandas as pd
import numpy as np

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.cluster import KMeans

import matplotlib.pyplot as plt

# ЯЧЕЙКА 3: Очистка и приведение колонки "Сумма, тг." к числу

price_col = "Сумма, тг."

def clean_price(x):
    if pd.isna(x):
        return np.nan
    s = str(x)
    # убираем пробелы
    s = s.replace(" ", "")
    # убираем все, кроме цифр, точки и запятой
    s = ''.join(ch for ch in s if ch.isdigit() or ch in [".", ","])
    # заменяем запятую на точку
    s = s.replace(",", ".")
    if s == "" or s == ".":
        return np.nan
    try:
        return float(s)
    except ValueError:
        return np.nan

df[price_col] = df[price_col].apply(clean_price)

df[price_col].describe()

# ЯЧЕЙКА 4: Удаляем строки, где цена NaN или <= 0

initial_rows = len(df)
df = df[df[price_col].notna()]
df = df[df[price_col] > 0]

print(f"Было строк: {initial_rows}")
print(f"Осталось строк после фильтра по цене: {len(df)}")

# ЯЧЕЙКА 5: Парсим даты (по необходимости)

date_cols = [
    "Начало приема заявок",
    "Окончание приема заявок",
    "Детали_Дата публикации",
    "Детали_Срок начала приема",
    "Детали_Срок окончания приема"
]

for c in date_cols:
    if c in df.columns:
        df[c] = pd.to_datetime(df[c], errors="coerce", dayfirst=True)

df[date_cols].head()

# ЯЧЕЙКА 6: Подготовка текста

text_col = "Наименование объявления"

# на всякий случай заменим NaN на пустую строку
df[text_col] = df[text_col].fillna("")

# можно добавить также Детали_Наименование, если хочешь объединить
if "Детали_Наименование объявления" in df.columns:
    df["full_title"] = (
        df[text_col].astype(str) + " " +
        df["Детали_Наименование объявления"].astype(str)
    )
    text_for_tfidf = df["full_title"]
else:
    text_for_tfidf = df[text_col]

# ЯЧЕЙКА 7: TF-IDF векторизация

tfidf = TfidfVectorizer(
    # простой вариант, без кастомных токенайзеров для русского
    max_df=0.8,        # игнорируем слишком частые слова
    min_df=5,          # игнорируем очень редкие слова
    ngram_range=(1, 2) # учитываем униграммы и биграммы
)

X_tfidf = tfidf.fit_transform(text_for_tfidf)

X_tfidf.shape

# ЯЧЕЙКА 8: Функция поиска топ-N похожих тендеров по тексту

def get_similar_tenders(idx, top_n=10):
    """
    idx - индекс строки в df
    top_n - сколько похожих записей вернуть
    """
    # берем вектор конкретного тендера
    vec = X_tfidf[idx]
    # считаем косинусную близость со всеми
    sims = cosine_similarity(vec, X_tfidf).flatten()
    # сортируем по убыванию
    similar_idx = sims.argsort()[::-1]
    # убираем сам объект (idx)
    similar_idx = [i for i in similar_idx if i != idx]
    # выбираем top_n
    top_idx = similar_idx[:top_n]

    result = df.iloc[top_idx].copy()
    result["similarity"] = sims[top_idx]
    return result

# Пример: берем тендер с индексом 0 и смотрим 5 самых похожих
similar_to_0 = get_similar_tenders(0, top_n=5)
similar_to_0[[text_col, price_col, "similarity"]]

# ЯЧЕЙКА 9: Обучение KMeans на TF-IDF

n_clusters = 30  # можно поиграться этим параметром

kmeans = KMeans(
    n_clusters=n_clusters,
    random_state=42,
    n_init=10
)
df["cluster"] = kmeans.fit_predict(X_tfidf)

df[["cluster", text_col]].head()

# ЯЧЕЙКА 10: Распределение тендеров по кластерам

cluster_counts = df["cluster"].value_counts().sort_index()
cluster_counts

# ЯЧЕЙКА 11: Расчёт IQR по кластерам и флаг аномальной цены

def calc_iqr_flags(df, price_col="Сумма, тг.", cluster_col="cluster"):
    grouped = df.groupby(cluster_col)[price_col]

    stats = grouped.quantile([0.25, 0.5, 0.75]).unstack()
    stats.columns = ["q1", "median", "q3"]
    stats["iqr"] = stats["q3"] - stats["q1"]
    stats["upper_bound"] = stats["q3"] + 1.5 * stats["iqr"]

    # join обратно к df
    df = df.join(stats, on=cluster_col)

    df["price_outlier_high"] = df[price_col] > df["upper_bound"]

    return df, stats

df, cluster_price_stats = calc_iqr_flags(df, price_col=price_col, cluster_col="cluster")

df[["cluster", price_col, "q1", "median", "q3", "upper_bound", "price_outlier_high"]].head()

# ЯЧЕЙКА 12: Сколько аномально дорогих тендеров

df["price_outlier_high"].value_counts()

# ЯЧЕЙКА 13: Признаки риска (rule-based)

# 1) факт приглашённого поставщика
invited_col = "Общие_Приглашенный поставщик"
df["has_invited_supplier"] = df[invited_col].notna()

# 2) подозрительный способ закупки (пример - подставь реальные значения)
suspicious_methods = [
    "Закупка из одного источника",
    "Из одного источника",
    "У одного источника"
]

method_col = "Общие_Способ проведения закупки"

df["suspicious_method"] = df[method_col].isin(suspicious_methods)

# 3) очень короткий период приёма заявок (например, < 3 дней)
if "Начало приема заявок" in df.columns and "Окончание приема заявок" in df.columns:
    df["tender_duration_days"] = (
        (df["Окончание приема заявок"] - df["Начало приема заявок"])
        .dt.total_seconds() / (24 * 3600)
    )
    df["short_duration"] = df["tender_duration_days"] < 3
else:
    df["short_duration"] = False

# 4) базовый риск-скоринг (чем больше факторов, тем выше риск)
df["risk_score"] = (
    df["price_outlier_high"].astype(int) * 3 +
    df["has_invited_supplier"].astype(int) * 2 +
    df["suspicious_method"].astype(int) * 2 +
    df["short_duration"].astype(int) * 1
)

df[["ID", text_col, price_col, "cluster", "price_outlier_high",
    "has_invited_supplier", "suspicious_method", "short_duration", "risk_score"]].head()

# ЯЧЕЙКА 14: Отбор подозрительных тендеров

risk_threshold = 4
suspicious_df = df[df["risk_score"] >= risk_threshold].copy()

print(f"Подозрительных тендеров: {len(suspicious_df)}")

suspicious_df.sort_values("risk_score", ascending=False).head(20)[
    ["ID", text_col, price_col, "risk_score",
     "price_outlier_high", "has_invited_supplier", "suspicious_method", "short_duration"]
]

df["lower_bound"] = df["q1"] - 1.5 * df["iqr"]
df["price_outlier_low"] = df[price_col] < df["lower_bound"]

cluster_sizes = df.groupby("cluster").size().rename("cluster_size")
df = df.join(cluster_sizes, on="cluster")

# считаем price_outlier_high только если в кластере достаточно объектов
min_cluster_size = 10
df.loc[df["cluster_size"] < min_cluster_size, "price_outlier_high"] = False

invited_col = "Общие_Приглашенный поставщик"

df[invited_col] = df[invited_col].fillna("").astype(str).str.strip()
bad_values = {"", "0", "-", "нет", "нету", "отсутствует"}

df["has_invited_supplier"] = ~df[invited_col].str.lower().isin(bad_values)

method_col = "Общие_Способ проведения закупки"

df[method_col] = df[method_col].fillna("")

pattern = "одного источника"
df["suspicious_method"] = df[method_col].str.lower().str.contains(pattern)

df["tender_duration_days"] = (
    (df["Окончание приема заявок"] - df["Начало приема заявок"])
    .dt.total_seconds() / (24 * 3600)
)

df["short_duration"] = df["tender_duration_days"] < 3
df.loc[df["tender_duration_days"].isna(), "short_duration"] = False
df.loc[df["tender_duration_days"] < 0, "short_duration"] = True  # явный странный кейс

import joblib
from dataclasses import dataclass, field

@dataclass
class TenderRiskModel:
    price_col: str = "Сумма, тг."
    text_col: str = "Наименование объявления"
    invited_col: str = "Общие_Приглашенный поставщик"
    method_col: str = "Общие_Способ проведения закупки"
    start_date_col: str = "Начало приема заявок"
    end_date_col: str = "Окончание приема заявок"
    n_clusters: int = 30
    risk_threshold: int = 4

    tfidf: TfidfVectorizer = field(default=None, init=False)
    kmeans: KMeans = field(default=None, init=False)
    cluster_price_stats_: pd.DataFrame = field(default=None, init=False)
    suspicious_methods: list = field(default_factory=lambda: ["одного источника"], init=False)

    def _prepare_price(self, df):
        # предполагаем, что ты уже почистил цену в исходном df
        return df

    def fit(self, df: pd.DataFrame):
        df = df.copy()
        df = self._prepare_price(df)

        # 1) TF-IDF по тексту
        text = df[self.text_col].fillna("")
        self.tfidf = TfidfVectorizer(max_df=0.8, min_df=5, ngram_range=(1, 2))
        X_tfidf = self.tfidf.fit_transform(text)

        # 2) Кластеризация
        self.kmeans = KMeans(n_clusters=self.n_clusters, random_state=42, n_init=10)
        df["cluster"] = self.kmeans.fit_predict(X_tfidf)

        # 3) IQR по кластерам
        grouped = df.groupby("cluster")[self.price_col]
        stats = grouped.quantile([0.25, 0.5, 0.75]).unstack()
        stats.columns = ["q1", "median", "q3"]
        stats["iqr"] = stats["q3"] - stats["q1"]
        stats["upper_bound"] = stats["q3"] + 1.5 * stats["iqr"]
        stats["lower_bound"] = stats["q1"] - 1.5 * stats["iqr"]
        self.cluster_price_stats_ = stats

        return self

    def _add_features(self, df: pd.DataFrame):
        df = df.copy()

        # текст -> кластеры
        text = df[self.text_col].fillna("")
        X_tfidf = self.tfidf.transform(text)
        df["cluster"] = self.kmeans.predict(X_tfidf)

        # join IQR
        stats = self.cluster_price_stats_
        df = df.join(stats, on="cluster")

        # price outliers
        df["price_outlier_high"] = df[self.price_col] > df["upper_bound"]
        df["price_outlier_low"] = df[self.price_col] < df["lower_bound"]

        # invited supplier
        df[self.invited_col] = df[self.invited_col].fillna("").astype(str).str.strip()
        bad_values = {"", "0", "-", "нет", "нету", "отсутствует"}
        df["has_invited_supplier"] = ~df[self.invited_col].str.lower().isin(bad_values)

        # suspicious method
        df[self.method_col] = df[self.method_col].fillna("").astype(str)
        pattern = "одного источника"
        df["suspicious_method"] = df[self.method_col].str.lower().str.contains(pattern)

        # duration
        if self.start_date_col in df.columns and self.end_date_col in df.columns:
            start = pd.to_datetime(df[self.start_date_col], errors="coerce", dayfirst=True)
            end = pd.to_datetime(df[self.end_date_col], errors="coerce", dayfirst=True)
            df["tender_duration_days"] = (end - start).dt.total_seconds() / (24*3600)
            df["short_duration"] = df["tender_duration_days"] < 3
            df.loc[df["tender_duration_days"].isna(), "short_duration"] = False
            df.loc[df["tender_duration_days"] < 0, "short_duration"] = True
        else:
            df["short_duration"] = False

        return df

    def predict(self, df: pd.DataFrame):
        """
        Возвращает df с колонками:
        price_outlier_high, has_invited_supplier, suspicious_method,
        short_duration, risk_score, risk_flag
        """
        df_feat = self._add_features(df)

        df_feat["risk_score"] = (
            df_feat["price_outlier_high"].astype(int) * 3 +
            df_feat["has_invited_supplier"].astype(int) * 2 +
            df_feat["suspicious_method"].astype(int) * 2 +
            df_feat["short_duration"].astype(int) * 1
        )

        df_feat["risk_flag"] = df_feat["risk_score"] >= self.risk_threshold

        return df_feat

# обучаем на всём датасете (после очистки цены)
risk_model = TenderRiskModel(
    price_col="Сумма, тг.",
    text_col="Наименование объявления",
    n_clusters=30,
    risk_threshold=4
)

risk_model.fit(df)

import joblib
joblib.dump(risk_model, "tender_risk_model.pkl")

df

# ЯЧЕЙКА: добавляем risk_score, risk_flag, risk_level и сразу смотрим аутпут

def add_risk_outputs(df, risk_threshold=4):
    """
    df – DataFrame с колонками:
      price_outlier_high, has_invited_supplier, suspicious_method, short_duration
    risk_threshold – порог, начиная с которого тендер считается подозрительным
    """
    df = df.copy()

    # Если risk_score уже есть, можно пересчитать или оставить как есть.
    df["risk_score"] = (
        df["price_outlier_high"].astype(int) * 3 +
        df["has_invited_supplier"].astype(int) * 2 +
        df["suspicious_method"].astype(int) * 2 +
        df["short_duration"].astype(int) * 1
    )

    # Бинарный флаг "подозрительный тендер"
    df["risk_flag"] = df["risk_score"] >= risk_threshold

    # Текстовый уровень риска
    def score_to_level(s):
        if s >= 6:
            return "высокий"
        elif s >= 4:
            return "средний"
        elif s >= 1:
            return "низкий"
        else:
            return "нет"

    df["risk_level"] = df["risk_score"].apply(score_to_level)

    return df

# применяем функцию
df_with_risk = add_risk_outputs(df, risk_threshold=4)

# смотрим первые строки с основными аутпутами модели
cols_to_show = [
    "ID",
    "Наименование объявления",
    "Сумма, тг.",
    "cluster",
    "risk_score",
    "risk_level",
    "risk_flag",
    "price_outlier_high",
    "has_invited_supplier",
    "suspicious_method",
    "short_duration",
]

df_with_risk[cols_to_show].head(20)

df_with_risk.to_csv("df_with_risk.csv", index=False)

import json
import pandas as pd
import numpy as np

# Пример входного JSON (как будто его прислал curl на бэкенд)
request_json = {
    "tenders": [
        {
            "id": "15741196-1",
            "name": "Услуги по финансовому лизингу",
            "price": 353839700.0,
            "organizer": "ГУ «Госорган какой-то»",
            "invited_supplier": "ТОО «Рога и Копыта»",
            "method": "Закупка из одного источника",
            "start_date": "2024-02-10",
            "end_date": "2024-02-11"
        },
        {
            "id": "TEST-2",
            "name": "Приобретение хозяйственных товаров",
            "price": 270000.0,
            "organizer": "ГУ «Другое ведомство»",
            "invited_supplier": "",
            "method": "Открытый конкурс",
            "start_date": "2024-03-01",
            "end_date": "2024-03-15"
        }
    ]
}

print("Входной JSON (как будто с curl):")
print(json.dumps(request_json, ensure_ascii=False, indent=2))

from datetime import datetime

def score_tenders_like_api(request_json,
                           risk_threshold=4,
                           suspicious_pattern="одного источника"):
    """
    request_json: dict вида {"tenders": [ {...}, {...} ]}
    возвращает dict с результатами скоринга
    """

    # 1) Превращаем входной JSON в DataFrame в "формате датасета"
    records = []
    for t in request_json["tenders"]:
        records.append({
            "ID": t["id"],
            "Наименование объявления": t["name"],
            "Сумма, тг.": t["price"],
            "Общие_Приглашенный поставщик": t.get("invited_supplier"),
            "Общие_Способ проведения закупки": t.get("method"),
            "Начало приема заявок": t.get("start_date"),
            "Окончание приема заявок": t.get("end_date"),
        })

    df_req = pd.DataFrame(records)

    # приводим даты
    for col in ["Начало приема заявок", "Окончание приема заявок"]:
        df_req[col] = pd.to_datetime(df_req[col], errors="coerce", dayfirst=True)

    # 2) Кластеризация новых тендеров
    text = df_req["Наименование объявления"].fillna("")
    X_tfidf_req = tfidf.transform(text)
    df_req["cluster"] = kmeans.predict(X_tfidf_req)

    # 3) Подтягиваем IQR-статистику по кластерам
    stats = cluster_price_stats[["q1", "median", "q3", "iqr", "upper_bound"]]
    df_req = df_req.join(stats, on="cluster")

    # 4) Флаги и скоринг
    price_col = "Сумма, тг."

    df_req["price_outlier_high"] = df_req[price_col] > df_req["upper_bound"]

    # invited supplier
    invited_col = "Общие_Приглашенный поставщик"
    df_req[invited_col] = df_req[invited_col].fillna("").astype(str).str.strip()
    bad_values = {"", "0", "-", "нет", "нету", "отсутствует"}
    df_req["has_invited_supplier"] = ~df_req[invited_col].str.lower().isin(bad_values)

    # suspicious method
    method_col = "Общие_Способ проведения закупки"
    df_req[method_col] = df_req[method_col].fillna("").astype(str)
    df_req["suspicious_method"] = df_req[method_col].str.lower().str.contains(
        suspicious_pattern
    )

    # duration
    df_req["tender_duration_days"] = (
        (df_req["Окончание приема заявок"] - df_req["Начало приема заявок"])
        .dt.total_seconds() / (24 * 3600)
    )
    df_req["short_duration"] = df_req["tender_duration_days"] < 3
    df_req.loc[df_req["tender_duration_days"].isna(), "short_duration"] = False
    df_req.loc[df_req["tender_duration_days"] < 0, "short_duration"] = True

    # risk_score
    df_req["risk_score"] = (
        df_req["price_outlier_high"].astype(int) * 3 +
        df_req["has_invited_supplier"].astype(int) * 2 +
        df_req["suspicious_method"].astype(int) * 2 +
        df_req["short_duration"].astype(int) * 1
    )

    df_req["risk_flag"] = df_req["risk_score"] >= risk_threshold

    def score_to_level(s):
        if s >= 6:
            return "high"
        elif s >= 4:
            return "medium"
        elif s >= 1:
            return "low"
        else:
            return "none"

    df_req["risk_level"] = df_req["risk_score"].apply(score_to_level)

    # 5) Собираем JSON-ответ в стиле API
    response = {"tenders": []}

    for _, row in df_req.iterrows():
        response["tenders"].append({
            "id": row["ID"],
            "risk_score": int(row["risk_score"]),
            "risk_flag": bool(row["risk_flag"]),
            "risk_level": row["risk_level"],
            "features": {
                "price": float(row[price_col]),
                "cluster": int(row["cluster"]),
                "price_outlier_high": bool(row["price_outlier_high"]),
                "has_invited_supplier": bool(row["has_invited_supplier"]),
                "suspicious_method": bool(row["suspicious_method"]),
                "short_duration": bool(row["short_duration"]),
                "q1": float(row["q1"]) if not np.isnan(row["q1"]) else None,
                "median": float(row["median"]) if not np.isnan(row["median"]) else None,
                "q3": float(row["q3"]) if not np.isnan(row["q3"]) else None,
                "upper_bound": float(row["upper_bound"]) if not np.isnan(row["upper_bound"]) else None,
            }
        })

    return response

response_json = score_tenders_like_api(request_json, risk_threshold=4)

print("JSON-ответ модели (как будто от REST API):")
print(json.dumps(response_json, ensure_ascii=False, indent=2))

